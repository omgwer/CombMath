#include <iostream>
#include <vector>
#include <fstream>
#include <iomanip>


using namespace std;

/*3.3. [# 50] –î–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞, —Å–æ–¥–µ—Ä–∂–∞—â–µ–≥–æ ùë£ –≤–µ—Ä—à–∏–Ω, –Ω–∞–π–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–æ–≤–Ω—ã—Ö
–¥–µ—Ä–µ–≤—å–µ–≤.
–í—Ö–æ–¥. –ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–¥–Ω–æ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ùë£ (1 ‚â§ ùë£ ‚â§ 100) ‚Äì
–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω. –í–µ—Ä—à–∏–Ω—ã –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω—ã –æ—Ç 1 –¥–æ ùëõ. –í –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö ùë£ —Å—Ç—Ä–æ–∫–∞—Ö
—Å–æ–¥–µ—Ä–∂–∞—Ç—Å—è –ø–æ ùë£ —á–∏—Å–µ–ª, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–∞–º–∏: –≤–µ—Å —Ä–µ–±–µ—Ä –º–µ–∂–¥—É –≤–µ—Ä—à–∏–Ω–∞–º–∏.
–í—ã—Ö–æ–¥. –í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å—Å—è –æ–¥–Ω–æ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ ‚Äì –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
–æ—Å—Ç–æ–≤–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤.*/

/*
–§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—è –º–∞—Ç—Ä–∏—Ü—ã
—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Ä–∞–∑–±–∏–≤–∞—è –º–∞—Ç—Ä–∏—Ü—É –Ω–∞ –ø–æ–¥–º–∞—Ç—Ä–∏—Ü—ã –º–µ–Ω—å—à–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞, –∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã—á–∏—Å–ª—è–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å –º–∞—Ç—Ä–∏—Ü—ã –≥—Ä–∞—Ñ–∞,
—á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–π—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–æ–≤–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤ –≤ –≥—Ä–∞—Ñ–µ.
*/
int determinant(vector<vector<int>>& laplacian, int graphNodeCountMinisOne)
{
    int det = 0;
    //–ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã graphNodeCountMinisOne —Ä–∞–≤–µ–Ω 1, —Ç–æ —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º–∞—Ç—Ä–∏—Ü–∞ –∏–º–µ–µ—Ç —Ä–∞–∑–º–µ—Ä 1x1,
    //–∏ –º—ã –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç —ç—Ç–æ–π –º–∞—Ç—Ä–∏—Ü—ã –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å.
    if (graphNodeCountMinisOne == 1)
        return laplacian[0][0];
    // —Ä–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã graphNodeCountMinisOne —Ä–∞–≤–µ–Ω 2. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–æ—Ä–º—É–ª—É –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—è –º–∞—Ç—Ä–∏—Ü—ã 2x2.
    if (graphNodeCountMinisOne == 2)
        return laplacian[0][0] * laplacian[1][1] - laplacian[0][1] * laplacian[1][0];

    // –í –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö (–∫–æ–≥–¥–∞ —Ä–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã –±–æ–ª—å—à–µ 2), –º—ã —Å–æ–∑–¥–∞–µ–º –ø–æ–¥–º–∞—Ç—Ä–∏—Ü—É submat, –∫–æ—Ç–æ—Ä–∞—è —è–≤–ª—è–µ—Ç—Å—è –º–∞—Ç—Ä–∏—Ü–µ–π —Ä–∞–∑–º–µ—Ä–∞ (graphNodeCountMinisOne - 1) x (graphNodeCountMinisOne - 1).
    // –ú—ã –∏–¥–µ–º –ø–æ –∫–∞–∂–¥–æ–º—É —Å—Ç–æ–ª–±—Ü—É –º–∞—Ç—Ä–∏—Ü—ã laplacian –∏ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é determinant, –ø–µ—Ä–µ–¥–∞–≤–∞—è –ø–æ–¥–º–∞—Ç—Ä–∏—Ü—É submat, —É–¥–∞–ª—è—è —Ç–µ–∫—É—â–∏–π —Å—Ç–æ–ª–±–µ—Ü –∏ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É.
    vector<vector<int>> submat(graphNodeCountMinisOne - 1, vector<int>(graphNodeCountMinisOne - 1));
    for (int k = 0; k < graphNodeCountMinisOne; k++)
    {
        int subi = 0;
        for (int i = 1; i < graphNodeCountMinisOne; i++)
        {
            int subj = 0;
            for (int j = 0; j < graphNodeCountMinisOne; j++)
            {
                if (j != k)
                {
                    submat[subi][subj] = laplacian[i][j];
                    subj++;
                }
            }
            subi++;
        }
        // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ k –º—ã –≤—ã—á–∏—Å–ª—è–µ–º –º–∏–Ω–æ—Ä laplacian[0][k] (–ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –∏ k-—ã–π —Å—Ç–æ–ª–±–µ—Ü) –∏ —É–º–Ω–æ–∂–∞–µ–º –µ–≥–æ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–π
        // –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫ (k % 2 == 0 ? 1 : -1).
        // –ó–∞—Ç–µ–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é determinant –¥–ª—è –ø–æ–¥–º–∞—Ç—Ä–∏—Ü—ã submat, —É–º–Ω–æ–∂–µ–Ω–Ω–æ–π –Ω–∞ –º–∏–Ω–æ—Ä, –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫ –æ–±—â–µ–º—É –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—é det.
        det += (k % 2 == 0 ? 1 : -1) * laplacian[0][k] * determinant(submat, graphNodeCountMinisOne - 1);
    }

    return det;
}

int main()
{
    int graphNodeCount;
    ifstream in("test.txt");
    in >> graphNodeCount;

    // –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞
    vector<vector<int>> graph(graphNodeCount, vector<int>(graphNodeCount));
    for (int i = 0; i < graphNodeCount; i++)
    {
        for (int j = 0; j < graphNodeCount; j++)
        {
            in >> graph[i][j];
        }
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ –ª–∞–ø–ª–∞—Å–∏–∞–Ω–∞ (http://www.machinelearning.ru/wiki/images/9/9f/Novikov_SGT_presentation.pdf)
    vector<vector<int>> laplacian(graphNodeCount, vector<int>(graphNodeCount, 0));
    for (int i = 0; i < graphNodeCount; i++)
    {
        for (int j = 0; j < graphNodeCount; j++)
        {
            if (i != j)
            {
                laplacian[i][i] += graph[i][j];
                laplacian[i][j] = -graph[i][j];
            }
        }
    }

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ—Å—Ç–æ–≤–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
    int det = determinant(laplacian, graphNodeCount - 1);

    // –í—ã–≤–æ–¥ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ—Å—Ç–æ–≤–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
    cout << "Result " << det << endl;

    return 0;
}
